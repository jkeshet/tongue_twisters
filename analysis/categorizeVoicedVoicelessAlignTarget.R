# Categorize each production as voiced vs. voiceless, then align to target syllables.

##### CATEGORIZE EACH PRODUCTION AS VOICED VS. VOICELESS #####

# use mixdist library to fit mixture models
library(mixdist)

voicedProb.fnc = function (point, bin, mixpar) 
# return the probability that a given point [within an interval determined by bin] was generated by the voiced component of the mixture
{
    mu <- mixpar[, 2] # extract vector of mus
    points = c(point-bin,point) # begin, end point for interval
    sigma <- mixpar[, 3] # extract vector of sigmas
    par1 <- (mu/sigma)^2 # calculate shape parameter
    par2 <- mu/(sigma^2) # calculate rate parameter
    mixcdf <- t(sapply(points, pgamma, par1, par2)) # get probability of points for specified gamma distributions 
    pmat = rbind(mixcdf, 1) - rbind(0, mixcdf) # get probability observation falls within bin according to each component
    joint <-  sweep(pmat, 2, mixpar[, 1], "*") # weight probabilities by strength of component in mixture
    mixed <- apply(joint, 1, sum) # sum of probability from each component
    conditprob <- sweep(joint, 1, mixed, "/") # given it came from one component, what is the probability it came from each component?

return(conditprob[2,1]) # return the probability that a value within the bin was generated by the voiced component
}


# trim extreme values (upper 0.5% of observations) and bad VOTs
data = resultsVOT[resultsVOT$VOT < .144 & resultsVOT$VOT > 0,]

# store these excluded values to help with alignment procedure
excluded = resultsVOT[resultsVOT$VOT >= .144 | resultsVOT$VOT < 0,]

# initialize parameters for mixture model. 
dpar = mixparam(c(.01,.1),c(.01,.1))

# create a variable to store all of the VOT results, initializing new columns
keep = data[1,]
keep$voicedProb[1] = 999
keep$productionVoicing[1] = "blah"

# create a variable to store the data for each participant's fit
subjFits = data.frame(sort(rep(unique(data$Subject),3)),rep(unique(data$POA),length(unique(data$Subject))),1:(length(unique(data$Subject))*3),1:(length(unique(data$Subject))*3),1:(length(unique(data$Subject))*3),1:(length(unique(data$Subject))*3),1:(length(unique(data$Subject))*3))
colnames(subjFits)=c("Subject","POA","piVoiced","muVoiced","sigmaVoiced","muVoiceless","sigmaVoiceless")

# for each participantâ€¦
for (i in unique(data$Subject)){
	# for each place of articulation
	for(k in unique(data$POA)){
		subset = data[data$Subject==i & data$POA==k,]  # extract their subset of the data
		mixdata = mixgroup(subset$VOT,breaks=seq(0,.145,by=.005)) # group data into bins defined by breaks

		# attempt to fit mixture model four times
		fits  = list (1,2,3,4)
		# fit mixture model. first argument: vector of mus; second argument: vector of sigmas; default is mixture probabilty = 1/N of mixtures
		dpar = mixparam(c(.001,.1),c(.01,.1))
		fits[[1]] = mix(mixdata,dpar,"gamma",emsteps=10) # fit mixture model with gamma distribution, using up to 10 EM steps
		fits[[2]] = mix(mixdata,dpar,"gamma",emsteps=10) # re-fit in case of local minimum

		# fit model with different mus.
		dpar = mixparam(c(.01,.1),c(.01,.1))
		fits[[3]] = mix(mixdata,dpar,"gamma",emsteps=10)
		fits[[4]] = mix(mixdata,dpar,"gamma",emsteps=10)
		
		# find model with best fit to the data
		bestchisq = fits[[1]]$chisq
		bestchisqfit = 1
		for (l in 2:4){
			if (fits[[l]]$chisq < bestchisq){
				bestchisq = fits[[l]]$chisq
				bestchisqfit = l  
			}
		}	

		fit = fits[[l]]

		subset$voicedProb = sapply(subset$VOT,voicedProb.fnc,.001,fit$parameters) # for each observation, calculate probability it's voiced
		subset$productionVoicing = ifelse(subset$voicedProb>.5,"voiced","voiceless") # label voicing of the production  based on voiced probability
		keep=rbind(keep,subset) # add on these observations to store of results
		j = (which(unique(data$Subject)==i) -1)*3# identify which row in the subject dataframe this subject is located
		j = j + which(unique(data$POA)==k) # add on value for POA
		subjFits$piVoiced[j] = fit$parameters[,1][1]
		subjFits$muVoiced[j] = fit$parameters[,2][1]
		subjFits$sigmaVoiced[j] = fit$parameters[,3][1]
		subjFits$muVoiceless[j] = fit$parameters[,2][2]
		subjFits$sigmaVoiceless[j] = fit$parameters[,3][2]
	}
}


newdata = keep[-1,] # drop the dummy first observation

# save results
write.table(subjFits,"subjectFits.txt",quote=F,sep="\t",row.names=F)
write.table(newdata,file="resultsVOTprobs.txt",quote=F,sep="\t",row.names=F)


##### ALIGN VOTS TO TARGET SYLLABLES #####

# use cba library for performing string alignment
library(cba)

#default: Assume it's same as position in VOT sequence
newdata$targetPosition = newdata$Sequence

# for processing, add back in excluded data
excluded$voicedProb = -999
# assume very long VOTs are voiceless, underspecify missing VOTs
excluded$productionVoicing = ifelse (excluded$VOT > 0, "voiceless", "x")
excluded$targetPosition = excluded$Sequence

newdata = rbind(newdata,excluded)

# reorder so that within each trial items appear in sequence
newdata = newdata[order(newdata$Subject,newdata$TrialLabel,newdata$Sequence),]
row.names(newdata)= NULL

# target strings d = voiced, s = voiceless
ABAB.voiced = "dsdsdsdsdsds"
ABAB.voiceless = "sdsdsdsdsdsd"
ABBA.voiced = "dssddssddssd"
ABBA.voiceless = "sddssddssdds"

# for each subject
for (i in unique(newdata$Subject)){
	# for each trial 
	for (j in unique(newdata$TrialLabel[newdata$Subject==i])){
		# if fewer than 12 responses
		if (max(newdata$Sequence[newdata$Subject==i & newdata$TrialLabel==j]) < 12){
			# determine target string
			if (newdata$Order[newdata$Subject==i & newdata$TrialLabel==j & newdata$Sequence==1] == "ABBA"){
				if (newdata$Ordering[newdata$Subject==i & newdata$TrialLabel==j & newdata$Sequence==1] == "a"){
					if (newdata$VoicingA[newdata$Subject==i & newdata$TrialLabel==j & newdata$Sequence==1] == "voiced")	{
						targetString = ABBA.voiced
					}
					else {
						targetString = ABBA.voiceless
					}
				}
				else {
					if (newdata$VoicingB[newdata$Subject==i & newdata$TrialLabel==j & newdata$Sequence==1] == "voiced")	{
						targetString = ABBA.voiced
					}
					else {
						targetString = ABBA.voiceless
					}
				}
				} else {
				if (newdata$Ordering[newdata$Subject==i & newdata$TrialLabel==j & newdata$Sequence==1] == "a"){
					if (newdata$VoicingA[newdata$Subject==i & newdata$TrialLabel==j & newdata$Sequence==1] == "voiced")	{
						targetString = ABAB.voiced
					}
					else {
						targetString = ABAB.voiceless
					}
				}
				else {
					if (newdata$VoicingB[newdata$Subject==i & newdata$TrialLabel==j & newdata$Sequence==1] == "voiced")	{
						targetString = ABAB.voiced
					}
					else {
						targetString = ABAB.voiceless
					}
				}
				}
			
			# get actual output string
			 
			outputString = paste(substr(newdata$productionVoicing[newdata$Subject==i & newdata$TrialLabel==j],nchar(newdata$productionVoicing[newdata$Subject==i & newdata$TrialLabel==j]),nchar(newdata$productionVoicing[newdata$Subject==i & newdata$TrialLabel==j])),collapse='')
				
			# Find minimum edit distance
			# Method is 'operator weighted' distance. Vector is costs of deletion, insertion, match, and replacement
			# Do not allow any insertions into target string. Prefer deletion to replacement
			stringMap = sdists.trace(targetString,outputString,method="ow",weight=c(1,Inf,0,2))

			# if more than one option pick one where deletions occur at end of string
			if (length(stringMap)>1){
				maxCost = 0
				maxNum = 0
				for (l in 1:length(stringMap)){
					editString = strsplit(names(stringMap[l]),"")
					editString = editString[[1]]
					p = 1:length(editString)
					q = rep(0,length(editString))
					editString = replace(editString,editString!="D",q[editString!="D"])
					editString = replace(editString,editString=="D",p[editString=="D"])
					cost = sum(strtoi(editString))
					if (cost > maxCost){
						maxCost = cost
						maxNum = l
					}
				}		
			} else{
				maxNum = 1
			}

			# find the deleted syllables
			deletedSyllables = which(strsplit(names(stringMap[maxNum]), "")[[1]]=="D")

			# Replace deleted syllables with 0, return remaining
			order = 1:12
			order[deletedSyllables] = 0
			order = order[order >0]
			
			# add to data frame
			newdata$targetPosition[newdata$Subject==i & newdata$TrialLabel==j] = order
						
			} # if < 12
		}
	}

# re-remove excluded trials
newdata = newdata[newdata$voicedProb != -999,]
row.names(newdata) = NULL

# save results
write.table(newdata,"resultsVOTaligned.txt",row.names=F,sep="\t",quote=F)

# associate each trial with target syllable info

# position in each of the 3 lines in the tongue twister
newdata$linePosition = ifelse(newdata$targetPosition %% 4 == 0, 4, newdata$targetPosition %% 4)

# element (A or B) is based on its position within the tongue twister line
newdata$element = substr(newdata$Order,newdata$linePosition,newdata$linePosition)
# actual element depends whether A or B occurs first
newdata$elementInOrder = ifelse (newdata$Ordering=="a",newdata$element,ifelse(newdata$element=="A","B","A"))
# If a minimal pair, either target is a word; if not a minimal pair, A element is a word, B a nonword
newdata$targetLexicality = ifelse (newdata$Pair.Status == "minPair","word",ifelse(newdata$elementInOrder=="A","word","nonword"))
# If a minimal pair, either outcome is a word; if not a minimal pair, B element has a word outcome, A a nonword
newdata$outcomeLexicality = ifelse (newdata$Pair.Status == "minPair","word",ifelse(newdata$elementInOrder=="B","word","nonword"))
# target voicing depends on position in sequence
newdata$targetVoicing = ifelse(newdata$elementInOrder == "A",newdata$VoicingA,newdata$VoicingB)

# load in subject data
subData =read.delim("subjectData.csv",sep=",")
# merge in information about subjects
newdata = merge(subData,newdata)

# trial in sequence depends on actual list twister came from
newdata$trialNumber = ifelse(newdata$List == 1,newdata$Script1,newdata$Script2)

# load in twister data, merge into data frame
twisterData = read.delim("lookup_numbered.csv",sep=",",as.is=T)
syllables = twisterData[,c("TrialLabel","Syl1","Syl2","Syl3","Syl4")]
newdata = merge(newdata,syllables,as.is=T)
newdata = newdata[order(newdata$Subject,newdata$TrialLabel,newdata$targetPosition),]
row.names(newdata) = NULL
# determine target syllable based on position in sequence
newdata$Syllable = ifelse(newdata$linePosition == 1,newdata$Syl1, ifelse(newdata$linePosition == 2,newdata$Syl2,ifelse(newdata$linePosition == 3,newdata$Syl3,newdata$Syl4)))

# accuracy is based on relationship between target, production voicing
newdata$correct = ifelse(newdata$targetVoicing==newdata$productionVoicing,"correct","error")



#save results
write.table(newdata,"resultsVOTinfo.txt",row.names=F,sep="\t",quote=F)